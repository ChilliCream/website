<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>GraphQL - Schema Stitching with Version 8 · ChilliCream</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="We are currently working on version 8 of Hot Chocolate and are mainly focusing on schema stitching with this release."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="GraphQL - Schema Stitching with Version 8 · ChilliCream"/><meta property="og:type" content="website"/><meta property="og:url" content="https://chillicream.com/blog/2019/02/20/schema-stitching"/><meta property="og:description" content="We are currently working on version 8 of Hot Chocolate and are mainly focusing on schema stitching with this release."/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://chillicream.com/img/signet.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css"/><link rel="alternate" type="application/atom+xml" href="https://chillicream.com/blog/atom.xml" title="ChilliCream Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://chillicream.com/blog/feed.xml" title="ChilliCream Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-72800164-1', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:700,400"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script type="text/javascript" src="/js/google-adsense.js"></script><script type="text/javascript" src="/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/signet.png" alt="ChilliCream"/><h2 class="headerTitleWithLogo">ChilliCream</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>All blog posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">All blog posts</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/blog/2019/02/20/schema-stitching">GraphQL - Schema Stitching with Version 8</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/02/04/instrumentation-and-apollo-tracing">GraphQL .NET Instrumentation API and Apollo Tracing</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/02/04/hot-chocolate-0.7.0">GraphQL - Hot Chocolate 0.7.0</a></li><li class="navListItem"><a class="navItem" href="/blog/2019/01/24/schema-stitching">GraphQL - Schema Stitching</a></li><li class="navListItem"><a class="navItem" href="/blog/2018/11/07/docusaurus-docs-redirect">Docusaurus - How to redirect requests to /docs to a default url instead of getting a 404 error</a></li><li class="navListItem"><a class="navItem" href="/blog/2018/09/02/hot-chocolate-0.4.5">GraphQL - Hot Chocolate 0.4.5</a></li><li class="navListItem"><a class="navItem" href="/blog/2018/07/31/hot-chocolate-0.4.0">GraphQL - Hot Chocolate 0.4.0</a></li><li class="navListItem"><a class="navItem" href="/blog/2018/07/30/green-donut-0.2.0">Green Donut 0.2.0</a></li><li class="navListItem"><a class="navItem" href="/blog/2018/05/03/react-rasta-1.0.0">React Rasta 1.0.0</a></li><li class="navListItem"><a class="navItem" href="/blog/2013/09/12/jquery-steps-form-wizard">How to create a Form Wizard using jQuery Steps</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/02/20/schema-stitching">GraphQL - Schema Stitching with Version 8</a></h1><p class="post-meta">February 20, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="https://github.com/michaelstaib" target="_blank" rel="noreferrer noopener">Michael Staib</a></p><div class="authorPhoto"><a href="https://github.com/michaelstaib" target="_blank" rel="noreferrer noopener"><img src="https://avatars1.githubusercontent.com/u/9714350?s=100&amp;v=4" alt="Michael Staib"/></a></div></div></header><div><span><p>We are currently working on version 8 of Hot Chocolate and are mainly focusing on schema stitching with this release.</p>
<p>One of the most requested features in this area was auto-stitching. Auto-stitching will enable us to automatically pull in schemas from other GraphQL servers and merge those into one schema.</p>
<!--truncate-->
<h2><a class="anchor" aria-hidden="true" id="auto-stitching"></a><a href="#auto-stitching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Auto-Stitching</h2>
<p>So, how does this work without making a big mess? With version 8 we are introducing a new builder class called <code>StitchingBuilder</code>.</p>
<p>The <code>StitchingBuilder</code> will allow us to define through a simple API, what schemas we want to merge.</p>
<p>Moreover, the <code>StitchingBuilder</code> allows us to define merge rules in order to customize the merging process to our needs.</p>
<p>Let us start with a simple example. In the last stitching blog post I provided two schemas, one was focusing on customer data and the other one was focusing on the contracts that a customer has with the company.</p>
<p>Customer Schema:</p>
<pre><code class="hljs css language-graphql">type Query {
  customer(id: ID!):<span class="hljs-built_in"> Customer
</span>  consultant(id: ID!): Consultant
  customerOrConsultant(id: ID!): CustomerOrConsultant
}
<span class="hljs-built_in">
type Customer </span>{
  id: ID!
  name: String!
  consultant: Consultant
}
<span class="hljs-built_in">
type </span>Consultant {
  id: ID!
  name: String!
}

union CustomerOrConsultant =<span class="hljs-built_in"> Customer </span>| Consultant
</code></pre>
<p>Contract Schema:</p>
<pre><code class="hljs css language-graphql">type Query {
  contract(contractId: ID!): Contract
  contracts(customerId: ID!): [Contract!]
}
<span class="hljs-built_in">
interface </span>Contract {
  id: ID!
}
<span class="hljs-built_in">
type </span>LifeInsuranceContract implements Contract {
  id: ID!
  premium: Float
}
<span class="hljs-built_in">
type </span>SomeOtherContract implements Contract {
  id: ID!
  expiryDate: DateTime
}
</code></pre>
<p>In order to merge the two schemas with pour new API we basically have to write the following code:</p>
<pre><code class="hljs css language-csharp">services.AddHttpClient(<span class="hljs-string">"customer"</span>, client =&gt; client.BaseAddress = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">"http://127.0.0.1:5050"</span>));
services.AddHttpClient(<span class="hljs-string">"contract"</span>, client =&gt; client.BaseAddress = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">"http://127.0.0.1:5051"</span>));

services.AddStitchedSchema(builder =&gt; builder
    .AddSchemaFromHttp(<span class="hljs-string">"contract"</span>)
    .AddSchemaFromHttp(<span class="hljs-string">"customer"</span>));
</code></pre>
<p>With that the <code>StitchingBuilder</code> will pull in the schemas from the provided endpoints and create the following schema:</p>
<p>Customer Schema:</p>
<pre><code class="hljs css language-graphql">type Query {
  customer(id: ID!):<span class="hljs-built_in"> Customer
</span>  consultant(id: ID!): Consultant
  customerOrConsultant(id: ID!): CustomerOrConsultant
  contract(contractId: ID!): Contract
  contracts(customerId: ID!): [Contract!]
}
<span class="hljs-built_in">
type Customer </span>{
  id: ID!
  name: String!
  consultant: Consultant
}
<span class="hljs-built_in">
type </span>Consultant {
  id: ID!
  name: String!
}

union CustomerOrConsultant =<span class="hljs-built_in"> Customer </span>| Consultant
<span class="hljs-built_in">
interface </span>Contract {
  id: ID!
}
<span class="hljs-built_in">
type </span>LifeInsuranceContract implements Contract {
  id: ID!
  premium: Float
}
<span class="hljs-built_in">
type </span>SomeOtherContract implements Contract {
  id: ID!
  expiryDate: DateTime
}
</code></pre>
<p>Without doing much we now have one schema, but we would like to improve our merged schema and integrate the types with each other.</p>
<h2><a class="anchor" aria-hidden="true" id="extending-types"></a><a href="#extending-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extending Types</h2>
<p>For example, we would like the <code>Customer</code> to have a property <code>contracts</code> that exposes the contracts of that particular customer.</p>
<p>The GraphQL SDL supports a keyword <code>extend</code> which basically lets us extend existing types.</p>
<p>With the new <code>StitchingBuilder</code> we added support for this.</p>
<pre><code class="hljs css language-graphql"><span class="hljs-selector-tag">extend</span> <span class="hljs-selector-tag">type</span> <span class="hljs-selector-tag">Customer</span> {
  <span class="hljs-attribute">contracts</span>: [Contract!]
    <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"contract"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"contracts(customerId:$fields:id)"</span>)
}
</code></pre>
<p>Instead of providing the fully stitched schema we can now describe the missing bits of our schema and add those like the following:</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
    .AddSchemaFromHttp(<span class="hljs-string">"contract"</span>)
    .AddSchemaFromHttp(<span class="hljs-string">"customer"</span>)
    .AddExtensionsFromFile(<span class="hljs-string">"extensions.graphql"</span>));
</code></pre>
<p>The extension files can also contain new types or types that we want to replace in the merged schema.</p>
<blockquote>
<p>Extended fields can also be bound to field resolvers.</p>
</blockquote>
<p>We now have a schema that is more consistent and allows us to fetch the customer and it's contracts with one request.</p>
<h2><a class="anchor" aria-hidden="true" id="rewriter"></a><a href="#rewriter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rewriter</h2>
<p>So, this is nice, but what if we want to remove parts of the schema or rename types.</p>
<p>The <code>StitchingBuilder</code> can be enhanced by writing schema rewriters. We added a bunch of schema rewriters for cases we found useful.</p>
<p>This basically means that we do not have to write schema rewriters for every little thing like renaming a type.</p>
<p>Let us for example rename the <code>LifeInsuranceContract</code> to <code>LifeInsurance</code>.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
    .AddSchemaFromHttp(<span class="hljs-string">"contract"</span>)
    .AddSchemaFromHttp(<span class="hljs-string">"customer"</span>)
    .AddExtensionsFromFile(<span class="hljs-string">"extensions.graphql"</span>)
    .RenameType(<span class="hljs-string">"contract"</span>, <span class="hljs-string">"LifeInsuranceContract"</span>, <span class="hljs-string">"LifeInsurance"</span>));
</code></pre>
<p>Next, we do not want to expose all the root-fields of the original schemas. So, lets say we only want to expose the root-fields from the customer schema and ignore the root-fields from the contracts schema.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
    .AddSchemaFromHttp(<span class="hljs-string">"contract"</span>)
    .AddSchemaFromHttp(<span class="hljs-string">"customer"</span>)
    .AddExtensionsFromFile(<span class="hljs-string">"extensions.graphql"</span>)
    .RenameType(<span class="hljs-string">"contract"</span>, <span class="hljs-string">"LifeInsuranceContract"</span>, <span class="hljs-string">"LifeInsurance"</span>)
    .IgnoreRootTypes(<span class="hljs-string">"contract"</span>));
</code></pre>
<p>Since, we are at it let us also get rid of the <code>customerOrConsultant</code> root field from the customer schema.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
    .AddSchemaFromHttp(<span class="hljs-string">"contract"</span>)
    .AddSchemaFromHttp(<span class="hljs-string">"customer"</span>)
    .AddExtensionsFromFile(<span class="hljs-string">"extensions.graphql"</span>)
    .RenameType(<span class="hljs-string">"contract"</span>, <span class="hljs-string">"LifeInsuranceContract"</span>, <span class="hljs-string">"LifeInsurance"</span>)
    .IgnoreRootTypes(<span class="hljs-string">"contract"</span>)
    .IgnoreField(<span class="hljs-string">"Query"</span>, <span class="hljs-string">"customerOrConsultant"</span>));
</code></pre>
<blockquote>
<p>If we do not specify the source schema with a rewriter, then the rewriter will be applied to all source schemas.</p>
</blockquote>
<p>After all those modifications our new stitched schema should look like the following:</p>
<pre><code class="hljs css language-graphql">type Query {
  customer(id: ID!):<span class="hljs-built_in"> Customer
</span>  consultant(id: ID!): Consultant
}
<span class="hljs-built_in">
type Customer </span>{
  id: ID!
  name: String!
  consultant: Consultant
  contracts: [Contract!]
    @delegate(schema: <span class="hljs-string">"contract"</span>, path: <span class="hljs-string">"contracts(customerId:<span class="hljs-variable">$fields</span>:id)"</span>)
}
<span class="hljs-built_in">
type </span>Consultant {
  id: ID!
  name: String!
}

union CustomerOrConsultant =<span class="hljs-built_in"> Customer </span>| Consultant
<span class="hljs-built_in">
interface </span>Contract {
  id: ID!
}
<span class="hljs-built_in">
type </span>Life implements Contract {
  id: ID!
  premium: Float
}
<span class="hljs-built_in">
type </span>SomeOtherContract implements Contract {
  id: ID!
  expiryDate: DateTime
}
</code></pre>
<p>The stitching layer will keep track of what we rename and rewrite queries to the source schema accordingly.</p>
<p>We can also write our own rewriter. There are basically two kinds of schema rewriter:</p>
<ul>
<li><p>Document Rewriter
This one operates on a schema document and is able to remove or add types.</p></li>
<li><p>Type Rewriter
The type rewriter operates on a type definition and can rename types, add, rename and remove fields or add directives to it.</p></li>
</ul>
<p>Custom rewriters can be defined like the following:</p>
<pre><code class="hljs css language-csharp">builder.AddTypeRewriter((schema, typeDefinition) =&gt;
{
    <span class="hljs-keyword">return</span> typeDefinition.Rename(<span class="hljs-string">"Foo"</span>);
})
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="merge-rules"></a><a href="#merge-rules" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Merge Rules</h2>
<p>Merge rules are at the heart of our auto-stitching functionality and basically describes how types are merged when we have name collisions.</p>
<p>For instance if we would have the following enum in both schemas, then we would merge it into one type in the target schema:</p>
<pre><code class="hljs css language-graphql"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CustomerType</span> </span>
{
    PERSON
    COMPANY
}
</code></pre>
<p>If, the enums would have the same name but different values for instance, we would rename one of the types:</p>
<pre><code class="hljs css language-graphql"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CustomerType</span></span>
{
    PERSON
}

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Contract_CustomerType</span></span>
{
    COMPANY
}
</code></pre>
<p>The enum merge rule would basically add the schema name in-front of the type name and thus create a unique new name.</p>
<p>Since, schema rewriters run before the merge rules are executed we can define our own name for the colliding type without writing a merge rule.</p>
<p>But, if we wanted to merge the enums nevertheless then we could write a merge rule that does exactly that.</p>
<p>The merge process defined as a chain of responsibility, where the rules are chained together and we pass along what we are not able to handle.</p>
<p>The merge process will bucket the types by name. Each merge rule gets a collection of types with the same name and then applies its merge logic to those types.</p>
<p>We can handle some of the types and pass the rest of the types to the next rule by invoking the <code>next</code> delegate.</p>
<pre><code class="hljs css language-csharp">builder.AddMergeHandler(next =&gt; (context, types) =&gt;
{
    <span class="hljs-comment">// merge logic goes here ...</span>
});
</code></pre>
<p>We have added some default merging rules that should suffice in most cases.</p>
<h2><a class="anchor" aria-hidden="true" id="code-first"></a><a href="#code-first" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code-First</h2>
<p>Since, the stitched schema is just a schema like any other, we can also add custom types with code first and that write a resolver that integrates those.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
    .AddSchemaFromHttp(<span class="hljs-string">"contract"</span>)
    .AddSchemaFromHttp(<span class="hljs-string">"customer"</span>)
    .AddExtensionsFromFile(<span class="hljs-string">"extensions.graphql"</span>)
    .RenameType(<span class="hljs-string">"contract"</span>, <span class="hljs-string">"LifeInsuranceContract"</span>, <span class="hljs-string">"LifeInsurance"</span>)
    .IgnoreRootTypes(<span class="hljs-string">"contract"</span>)
    .AddSchemaConfiguration(c =&gt;
    {
      c.RegisterType&lt;FooType&gt;();
    }));
</code></pre>
<p>The same way you can configure the execution pipeline with <code>AddExecutionConfiguration</code>.</p>
<p>We will add more code-first integration with the next release like <code>ObjectTypeExtension</code>, <code>InterfaceTypeExtension</code> and so on.</p>
<h2><a class="anchor" aria-hidden="true" id="remote-query-client"></a><a href="#remote-query-client" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Remote Query Client</h2>
<p>With this release we are now also introducing a stitching query client. This lets us delegate calls to a remote schema in our custom resolvers:</p>
<pre><code class="hljs css language-csharp">builder.AddSchemaConfiguration(config =&gt; 
{
    config.BindResolver(<span class="hljs-keyword">async</span> ctx =&gt; 
    {
        IRemoteQueryClient queryClient = 
            ctx.Service&lt;GetRemoteQueryClient&gt;()
            .GetRemoteQueryClient(<span class="hljs-string">"contract"</span>);
        IExecutionResult result = <span class="hljs-keyword">await</span> queryClient.ExecuteAsync(
            <span class="hljs-string">"{ foo { bar { baz } } }"</span>);
        <span class="hljs-keyword">return</span> ctx.HandleResult(result, <span class="hljs-string">"/foo"</span>);
    });
})
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="batching"></a><a href="#batching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Batching</h2>
<p>Like with <em>DataLoader</em> the stitching layer is now batching calls to the remote schemas. This reduces the calls to the remote-schemas significantly and improves the overall performance.</p>
<p>So, if we had two query calls:</p>
<p>Query 1:</p>
<pre><code class="hljs css language-graphql">{
  customer(<span class="hljs-name">id:</span> <span class="hljs-string">"abc"</span>) {
    name
    contracts {
      id
    }
  }
}
</code></pre>
<p>Query 2:</p>
<pre><code class="hljs css language-graphql">{
  customer(<span class="hljs-name">id:</span> <span class="hljs-string">"def"</span>) {
    name
    contracts {
      id
    }
  }
}
</code></pre>
<p>We would merge those two queries into one:</p>
<pre><code class="hljs css language-graphql">{
  __1: customer(<span class="hljs-name">id:</span> <span class="hljs-string">"abc"</span>) {
    name
    contracts {
      id
    }
  }
  __2: customer(<span class="hljs-name">id:</span> <span class="hljs-string">"def"</span>) {
    name
    contracts {
      id
    }
  }
}
</code></pre>
<p>This lets the remote schema optimize the calls much better since now the remote schema could take advantage of things like <em>DataLoader</em> etc.</p>
<h2><a class="anchor" aria-hidden="true" id="example"></a><a href="#example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example</h2>
<p>This post is based on Hot Chocolate version 0.8.0-preview.5. We have an example with the new API here: <a href="https://github.com/ChilliCream/hotchocolate-examples/tree/master/Stitching">Stitching Example</a></p>
<h2><a class="anchor" aria-hidden="true" id="todos"></a><a href="#todos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TODOs</h2>
<p>We are still quite busy with the current changes. We are working on renaming of input types and their fields and related areas.</p>
<p>Moreover, we are working to make it easy to stitch relay schemas together. The main issue with that at the moment is the node resolver.</p>
<p>Since, we can pass any ID to the node resolver and get the associated object returned we have to keep track of where those IDs come from.</p>
<p>We could ask all the node resolvers that we know, but this would feel not good. We think that we can finish this issues off by the end of this week and move to release the new stitching layer.</p>
<h2><a class="anchor" aria-hidden="true" id="version-9"></a><a href="#version-9" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Version 9</h2>
<p>We originally wanted to include subscription stitching with version 8, but are now moving this feature to next version.</p>
<p>Apart from that, Version 9 will mainly focus on schema improvements.</p>
<p>If you have feedback or feature requests for our schema stitching we love to talk to you about it. Head over to our slack channel:</p>
<table>
<thead>
<tr><th><a href="https://join.slack.com/t/hotchocolategraphql/shared_invite/enQtNTA4NjA0ODYwOTQ0LTBkZjNjZWIzMmNlZjQ5MDQyNDNjMmY3NzYzZjgyYTVmZDU2YjVmNDlhNjNlNTk2ZWRiYzIxMTkwYzA4ODA5Yzg">HotChocolate Slack Channel</a></th><th><a href="https://hotchocolate.io">Hot Chocolate Documentation</a></th><th><a href="https://github.com/ChilliCream/hotchocolate">Hot Chocolate on GitHub</a></th></tr>
</thead>
<tbody>
</tbody>
</table>
</span></div></div><div class="blogSocialSection"><div class="blogSocialSectionItem"><a href="https://twitter.com/share" class="twitter-share-button" data-text="GraphQL - Schema Stitching with Version 8" data-url="https://chillicream.com/blog/2019/02/20/schema-stitching" data-related="true" data-show-count="false">Tweet</a></div></div></div><div class="blog-recent"><a class="button" href="/blog">Recent posts</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#auto-stitching">Auto-Stitching</a></li><li><a href="#extending-types">Extending Types</a></li><li><a href="#rewriter">Rewriter</a></li><li><a href="#merge-rules">Merge Rules</a></li><li><a href="#code-first">Code-First</a></li><li><a href="#remote-query-client">Remote Query Client</a></li><li><a href="#batching">Batching</a></li><li><a href="#example">Example</a></li><li><a href="#todos">TODOs</a></li><li><a href="#version-9">Version 9</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/signet.png" alt="ChilliCream" width="64" height="64"/></a><div><h5>Projects</h5><a href="https://greendonut.io" target="_blank">Green Donut</a><a href="https://hotchocolate.io" target="_blank">Hot Chocolate</a><a href="https://react-rasta.com" target="_blank">React Rasta</a><a href="https://github.com/ChilliCream/thor-core" target="_blank">Thor</a></div><div><h5>Community</h5><a href="https://twitter.com/Chilli_Cream" target="_blank" rel="noreferrer noopener">Follow us on Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/ChilliCream/website" target="_blank">GitHub</a><a href="https://github.com/ChilliCream/website/issues" target="_blank">Issues</a><a class="github-button" href="https://github.com/ChilliCream/website" data-icon="octicon-star" data-count-href="/chillicream/website/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 ChilliCream</section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>